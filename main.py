# -*- coding: utf-8 -*-
"""mini_proyecto.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aMHTY0BvodN0KxmiAB7M1gdFS4Jt4olw
"""

!pip install opencv-python pytesseract googletrans==4.0.0-rc1 gTTS python-docx

!sudo apt install tesseract-ocr-spa

#importacion de librerias
import cv2
import pytesseract
from googletrans import Translator
from gtts import gTTS
from docx import Document
import os

def text_extraction(IMG_PATH):
  """
  recibe una imagen para procesar y extrae el texto
  in: IMG_PATH
  out: texto
  """
  try:
    img = cv2.imread(IMG_PATH)
    if img is None: #comprobar que la imagen exista
      print(f"Imagen np encontrada en: {IMG_PATH}")
      return None
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1] #me lo robe de stackoverflow, calcula automaticamente el umbral de colores

    config = "--oem 3 --psm 6 -l spa" #configura pytesseract para utilizar el idioma espanol con un OCR mas moderno
    text_extracted = pytesseract.image_to_string(thresh, config=config)

    cleaned_text = ''.join(c for c in text_extracted if c.isprintable() or c.isspace()) #une el texto extraido en un solo string


    print(cleaned_text)

    return cleaned_text
  except Exception as e:
    print(f"Error procesando imagen: {e}")
    return None

def sanitize_for_xml(text):
    """
    Elimina caracteres de control no permitidos por python-docx / XML.
    Mantiene tabs y saltos de lÃ­nea (\t, \n, \r).
    """
    if text is None:
        return ''
    if not isinstance(text, str):
        try:
            text = str(text)
        except Exception:
            text = ''
    allowed = []
    for ch in text:
        code = ord(ch)
        if code == 9 or code == 10 or code == 13 or code >= 32: #preserva los caracteres validos
            allowed.append(ch)
    return ''.join(allowed)

def translate_text(text, dest_lang = 'en'):
  """
  traduce texto a idioma especifico
  in: text = texto sin traducir
      dest_lang = idioma destino
  out: texto traducido
  """
  if not text.strip():
    print("Texto vacio")
    return ""
  try:
    translator = Translator()
    translated_text = translator.translate(text, dest=dest_lang)
    print(translated_text.text)
    return translated_text.text
  except Exception as e:
    print(f"Error traduciendo el texto: {e}")
    return "Error de traduccion"

def text_to_speech(text, file_name, lang):
  """
  convierte texto a audio
  in: text = texto a convertir
      file_name = nombre del archivo de audio
      lang = idioma del audio
  out: archivo mp3
  """
  if not text.strip():
    print("Texto vacio")
    return
  try:
    tts = gTTS(text=text, lang=lang, slow = False)
    tts.save(os.path.join(AUDIO_DIR, file_name))
    print(f"Audio guardado como {file_name}")
  except Exception as e:
    print(f"Error convirtiendo texto a voz: {e}")

def export_docx(text, head, file_name):
  """
  guarda el texto en un archivo docx
  in: text = texto a guardar
      head = titulo del documento
      file_name = nombre del archivo docx
  out: docx file
  """
  try:
      safe_head = sanitize_for_xml(head)
      safe_text = sanitize_for_xml(text)

      document = Document()
      if safe_head.strip():
          document.add_heading(safe_head, 0)
      if safe_text:
          document.add_paragraph(safe_text)
      document.save(os.path.join(DOCX_DIR, file_name))
      print(f"Documento guardado como {file_name}")
  except Exception as e:
      print(f"Error guardando docx: {e}")

def main():
  print(f"--- PROCESAND0 {IMG_PATH} ---")
  original_text = text_extraction(IMG_PATH)
  translated_text = None
  if original_text:
    while(True):
      q1 = input("Desea traducir el texto? (s/n): ")
      if q1.lower() == 's':
        translated_text = translate_text(original_text, dest_lang = 'en')
        break
      elif q1.lower() == 'n':
        break

    while(True):
      q2 = input("Desea convertir el texto a voz? (s/n): ")
      if q2.lower() == 's':
        audio_filename = os.path.basename(IMG_PATH) + '.mp3'
        text_to_speech(original_text, audio_filename, 'es')

        if translated_text:
          while(True):
            q2_trad = input("Desea convertir el texto traducido a voz? (s/n): ")
            if q2_trad.lower() == 's':
              translated_audio_filename = os.path.basename(IMG_PATH) + '_traducido.mp3'
              text_to_speech(translated_text, translated_audio_filename, 'en')
              break
            elif q2_trad.lower() == 'n':
              break

        break

      elif q2.lower() == 'n':
        break

    while(True):
      q3 = input("Desea exportar el texto a un documento .docx? (s/n): ")
      if q3.lower() == 's':
        head = input("Ingrese el titulo del documento: ")
        export_docx(original_text, head, head + '.docx')

        if translated_text:
          while(True):
            q3_trad = input("Desea convertir el texto traducido a .docx? (s/n): ")
            if q3_trad.lower() == 's':
              export_docx(translated_text, head + "_translated", head + '_translated.docx')
              break
            elif q3_trad.lower() == 'n':
              break

        break

      elif q3.lower() == 'n':
        break

if __name__ == "__main__":
  DOCX_DIR = './docx_files'
  AUDIO_DIR = './audio_files'
  if not os.path.exists(DOCX_DIR):
    os.makedirs(DOCX_DIR)
  if not os.path.exists(AUDIO_DIR):
    os.makedirs(AUDIO_DIR)
  IMG_DIR = './images'
  if not os.path.exists(IMG_DIR):
    os.makedirs(IMG_DIR)
  for filename in os.listdir(IMG_DIR):
    IMG_PATH = os.path.join(IMG_DIR, filename)
    main()